# Docker Study
## 1. 도커 기본
### 도커를 쓰는 이유
프로그램을 설치하는 과정에서 서버, 패키지 버전, 운영체제, 종속성 등에 따라 많은 에러가 발생함

도커를 사용하면 프로그램을 설치하는 과정을 간단하게 만들 수 있음

### 도커란?
컨테이너를 사용하여 응용프로그램을 쉽게 배포하고 실행할 수 있도록 설계된 컨테이너 기반의 오픈소스 가상화 플랫폼

다양한 프로그램, 실행환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공하여 프로그램의 배포 및 관리를 단순하게 해줌

**컨테이너**   
코드와 모든 종속성을 패키지화하여 응용프로그램이 한 컴퓨팅 환경에서 다른 컴퓨팅 환경으로 빠르고 안정적으로 실행되도록 하는 소프트웨어의 표준 단위   
이미지의 인스턴스이며, 프로그램을 실행함   
소프트웨어를 환경으로부터 격리시켜 인프라에 관계없이 동일하게 작동

**이미지**   
코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정과 같은 응용프로그램을 실행하는 데 필요한 모든 것을 포함하는 독립적이며 실행 가능한 소프트웨어 패키지   
런타임에 컨테이너로 생성됨

### VM과의 차이점
![docker-vm](https://user-images.githubusercontent.com/68456385/125197068-3f9b1800-e297-11eb-912a-1cc89b7a36fa.PNG)

**하이퍼바이저**   
호스트 시스템에서 다수의 게스트 OS를 구동할 수 있게 하는 소프트웨어   
하드웨어를 가상화하면서 하드웨어와 각각의 VM을 모니터링하는 중간 관리자

컨테이너는 하이퍼바이저와 게스트 OS가 필요하지 않으므로 더 가벼움

어플리케이션을 실행할 때 컨테이너 방식에서는 호스트 OS위에 어플리케이션의 실행 패키지인 이미지를 배포하기만 하면 되지만,    
VM에서 어플리케이션을 실행하기 위해선 VM을 띄우고 자원을 할당한 다음, 게스트 OS를 부팅하여 어플리케이션을 실행해야 해서 훨씬 복잡하고 무거움

### 컨테이너 격리
리눅스에서 쓰이는 Cgroup(Control group)과 namespace 이용   
-> 컨테이너와 호스트에서 실행되는 다른 프로세스 사이에 벽을 만드는 리눅스 커널 기능

이를 위해 도커를 설치하면 리눅스 VM이 설치되고, 그 위에서 도커가 작동됨

### 컨테이너 생성
이미지 안에는 컨테이너가 시작될 때 실행되는 명령어와 파일 스냅샷(실행하는 데 필요한 파일을 카피한 것)이 존재

1. 도커 이미지 실행(컨테이너 생성 및 실행)
    ```
    docker run <이미지>
    ```
    도커 클라이언트에 명령어 입력 후 도커 서버로 보냄   
    이미지가 로컬 이미지 캐시 보관 장소에 없다면 도커 허브에서 가져옴

2. 이미지에 있는 파일 스냅샷을 컨테이너 하드 디스크에 옮김

3. 이미지에 있는 명령어를 이용해서 프로그램 실행

![화면 캡처 2021-07-12 000234](https://user-images.githubusercontent.com/68456385/125200130-82afb800-e2a4-11eb-87d5-9eafbd142543.png)


## 2. 도커 클라이언트 명령어
도커 클라이언트에 명령어를 입력하면 도커 서버로 보내짐

docker - 도커 클라이언트 언급
### 도커 이미지 내부 파일 구조 보기
```
docker run <이미지> ls
```
이미지 이름 뒤에 추가 커맨드를 입력하면, 이미지가 가지고 있는 시작 명령어를 무시하고 뒤에 있는 커맨드 실행

** 이미지 파일 스냅샷에 실행가능한 ls 파일이 있어야 함

### 이미지 나열
```
docker images
```

### 실행 중인 컨테이너 나열
```
docker ps
```
컨테이너도 하나의 프로세스!

COMMAND: 컨테이너 시작 시 실행될 명령어   
STATUS: Up - 실행 중, Exited - 종료, Pause - 중지   
PORTS: 컨테이너가 개방한 포트와 호스트에 연결한 포트   
NAMES: 컨테이너의 고유한 이름. 컨테이너 생성 시 --name 옵션으로 설정 가능   
\+ docker rename original-name changed-name으로 재설정 가능

### 모든 컨테이너 나열
```
docker ps -a
```

### 도커 컨테이너 생명주기
![캡처](https://user-images.githubusercontent.com/68456385/126862887-f9f4a048-cf58-4029-a862-4b270d0ddb33.PNG)

### 컨테이너 중지
```
docker stop <컨테이너 id/이름>
```
Gracefully하게 중지   
하고 있던 작업이 모두 끝나면 중지

```
docker kill <컨테이너 id/이름>
```
바로 중지

\* docker run alpine ping localhost로 실행시켜 놓고 테스트

### 컨테이너 삭제
```
docker rm <컨테이너 id/이름>
```
중지된 컨테이너만 삭제 가능

### 모든 컨테이너 삭제
```
docker rm `docker ps -a -q`
```

### 이미지 삭제
```
docker rmi <이미지 id>
```

### 컨테이너, 이미지, 네트워크, 빌드 캐시 삭제
```
docker system prune
```
실행 중인 컨테이너의 시스템만 삭제됨

### 실행 중인 컨테이너에 명령어 전달
```
docker exec <컨테이너 id> <명령어>
```

### Redis 실행
1. Redis 서버 실행
```
docker run redis
```
2. Redis 클라이언트 실행
```
redis-cli
```
3. Redis 명령어 입력
```
set key1 hello
```
클라이언트에서 입력한 명령어가 서버로 전달

But, redis 서버는 컨테이너 안에서 실행되고 있기 때문에 컨테이너 밖에서 클라이언트를 실행할 수 없음   
-> 클라이언트도 컨테이너 안에서 실행시켜야됨 => exec 명령어 사용
```
docker exec -it <컨테이너 id> redis-cli
```
\* -it: interactive terminal. 명령어를 실행한 후 이어서 명령어를 작성할 수 있음. -it가 없으면 명령어를 실행하고 밖으로 나와버림

### 컨테이너를 쉘 환경으로 접근
```
docker exec -it <컨테이너 id> sh
```
매번 exec 명령어를 작성하지 않아도 됨

터미널 종료는 ctrl + d
